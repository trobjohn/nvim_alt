-- lua/repl.lua

local M = {}

local function term_job_to_right()
  local cur_win = vim.api.nvim_get_current_win()
  local cur_pos = vim.api.nvim_win_get_position(cur_win)

  for _, win in ipairs(vim.api.nvim_list_wins()) do
    local pos = vim.api.nvim_win_get_position(win)
    if pos[1] == cur_pos[1] and pos[2] > cur_pos[2] then
      local buf = vim.api.nvim_win_get_buf(win)
      if vim.bo[buf].buftype == "terminal" then
        local ok, job = pcall(vim.api.nvim_buf_get_var, buf, "terminal_job_id")
        if ok then return job end
      end
    end
  end
  return nil
end

local function get_visual_selection()
  -- If we're not in visual mode, return ""
  local mode = vim.fn.mode()
  if not (mode == "v" or mode == "V" or mode == "\22") then
    return ""
  end

  local srow, scol = unpack(vim.fn.getpos("'<"), 2, 3)
  local erow, ecol = unpack(vim.fn.getpos("'>"), 2, 3)

  if srow > erow or (srow == erow and scol > ecol) then
    srow, erow = erow, srow
    scol, ecol = ecol, scol
  end

  local lines = vim.api.nvim_buf_get_lines(0, srow - 1, erow, false)
  if #lines == 0 then return "" end

  lines[1] = string.sub(lines[1], scol)
  lines[#lines] = string.sub(lines[#lines], 1, ecol)

  return table.concat(lines, "\n")
end

local function send_to_job(job, text)
  -- normalize newlines
  text = text:gsub("\r\n", "\n")

  -- ensure final newline + blank line (closes Python blocks)
  if not text:match("\n$") then text = text .. "\n" end
  text = text .. "\n"

  -- terminals want carriage return to "press Enter"
  text = text:gsub("\n", "\r")

  vim.fn.chansend(job, text)
end

function M.send_visual_to_right_term()
  local job = term_job_to_right()
  if not job then
    vim.notify("No terminal found to the right", vim.log.levels.WARN)
    return
  end

  local text = get_visual_selection()
  if text == "" then
    vim.notify("No visual selection (use Visual mode V/v first)", vim.log.levels.WARN)
    return
  end

  send_to_job(job, text)
end

function M.send_current_line_to_right_term()
  local job = term_job_to_right()
  if not job then
    vim.notify("No terminal found to the right", vim.log.levels.WARN)
    return
  end

  local line = vim.api.nvim_get_current_line()
  send_to_job(job, line)
end

return M


-- Add to lua/repl.lua

local TMP_PY = "/tmp/nvim_block.py"

local function looks_like_ipython()
  -- crude but effective: check the terminal buffer name/title is hard;
  -- instead, allow user to pick by a global toggle if needed.
  return vim.g.repl_is_ipython == true
end

function M.send_visual_via_tmpfile()
  local job = term_job_to_right()
  if not job then
    vim.notify("No terminal found to the right", vim.log.levels.WARN)
    return
  end

  local text = get_visual_selection()
  if text == "" then
    vim.notify("No visual selection", vim.log.levels.WARN)
    return
  end

  -- normalize newlines
  text = text:gsub("\r\n", "\n")

  -- write selection to /tmp
  local lines = vim.split(text, "\n", { plain = true })
  vim.fn.writefile(lines, TMP_PY)

  -- run it in the current REPL namespace
  local cmd
  if looks_like_ipython() then
    cmd = ("%run -i %s"):format(TMP_PY)
  else
    -- plain python: emulate “run in current session”
    cmd = ("exec(compile(open(%q,'rb').read(), %q, 'exec'), globals())"):format(TMP_PY, TMP_PY)
  end

  -- send command + Enter
  vim.fn.chansend(job, cmd .. "\r")
end

